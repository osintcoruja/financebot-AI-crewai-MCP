# === PARTE 1: Imports, configura√ß√£o e MCP ===

from dotenv import load_dotenv
import os
import logging
from datetime import datetime, timedelta
from fastmcp import FastMCP

from langchain_openai import ChatOpenAI
from crewai import Agent, Task, Crew, Process
from crewai.memory import EntityMemory
from crewai.memory.storage.rag_storage import RAGStorage
from crewai_tools.adapters.mcp_adapter import MCPServerAdapter
from tools.relative_date_resolver import resolve_relative_date

load_dotenv()
mcp = FastMCP("assistente_financeiro_inteligente")

# Configura logs
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Par√¢metros MCP
try:
    from mcp import StdioServerParameters
    MCP_AVAILABLE = True
except ImportError:
    MCP_AVAILABLE = False

def try_initialize_mcp_adapter(params, name):
    try:
        logger.info(f"Inicializando adaptador MCP {name}...")
        return MCPServerAdapter(params)
    except Exception as e:
        logger.error(f"Erro ao iniciar MCP {name}: {e}")
        return None

from crewai.memory import EntityMemory
memoria_nova = EntityMemory()  # isso √© uma mem√≥ria "zerada"

# === PARTE 2: Mem√≥ria isolada e classifica√ß√£o de conversa ===

def get_session_memory(user_id: str, session_id: str):
    return EntityMemory(
        storage=RAGStorage(
            embedder_config={
                "provider": "openai",
                "config": {"model": "text-embedding-3-small"},
            },
            type="short_term",
            path=f"./memory_store/{user_id}/{session_id}/",
        )
    )

def is_new_conversation(question: str) -> bool:
    q = question.strip().lower()
    if q in {"sim", "n√£o", "confirmar", "cancelar", "ok", "certo"} or q.isdigit():
        return False
    if any(p in q for p in ["gastei", "recebi", "investi", "pre√ßo", "cota√ß√£o", "valor", "quanto", "quero", "oi", "ol√°"]):
        return True
    return len(q.split()) > 1

# === PARTE 3: Agente Classificador + Orquestrador ===

def criar_agente_classificador(tools, llm):
    return Agent(
        role="Classificador de Solicita√ß√µes",
        goal="Identificar se a solicita√ß√£o do usu√°rio √© sobre controle financeiro ou consulta de ativos.",
        backstory="Especialista em compreender inten√ß√µes financeiras e organizar informa√ß√µes.",
        tools=[],
        llm=llm,
        verbose=True,
        allow_delegation=False
    )

def criar_agente_orquestrador(tools, llm):
    return Agent(
        role="Orquestrador de Tarefas Financeiras",
        goal="Analisar a classifica√ß√£o e delegar a execu√ß√£o para a crew apropriada.",
        backstory="Gerente respons√°vel por direcionar tarefas para o time certo, garantindo fluidez e sucesso.",
        tools=tools,
        llm=llm,
        verbose=True,
        allow_delegation=True
    )

# === PARTE 4: Crew: Controle Financeiro ===

def crew_controle_financeiro(tools, llm, memory, dados_json):
    coletor_controle_financeiro = Agent(
        role="Coletor de Dados Financeiros",
        goal="Extrair e organizar os dados da transa√ß√£o financeira.",
        backstory="Especialista em captar detalhes de receitas e despesas em linguagem natural.",
        tools=tools,
        llm=llm,
        verbose=True,
        allow_delegation=False
    )

    gestor_dados = Agent(
        role="Gestor de Dados SQL",
        goal="Executar comandos SQL no Supabase conforme os dados coletados.",
        backstory="Especialista em persist√™ncia de dados e manipula√ß√£o de transa√ß√µes.",
        tools=tools,
        llm=llm,
        memory=memoria_nova,
        verbose=True,
        allow_delegation=False
    )

    redator = Agent(
        role="Comunicador Financeiro",
        goal="Gerar resposta clara e amig√°vel ao usu√°rio.",
        backstory="Respons√°vel por traduzir os dados da transa√ß√£o realizada no banco Supabase para linguagem humana.",
        tools=[],
        llm=llm,
        verbose=True,
        allow_delegation=False
    )

    task_coleta_controle_financeiro = Task(
    description=f"""üì• TAREFA: EXTRA√á√ÉO E ORGANIZA√á√ÉO DE DADOS FINANCEIROS

    üéØ Objetivo: Interpretar a mensagem do usu√°rio e **extrair um JSON completo** com os seguintes dados:

    - valor (float)
    - tipo (receita ou despesa)
    - categoria (como 'Sal√°rio', 'Alimenta√ß√£o', etc.)
    - conta_id (sempre 5)
    - data_transacao (formato ISO: YYYY-MM-DD)
    - descricao (sempre usar a frase original)

    ‚ö†Ô∏è **USO OBRIGAT√ìRIO DA TOOL `resolve_relative_date` PARA CALCULAR A DATA**:
    - A express√£o temporal (como "hoje", "ontem", "15/07") **deve ser passada para a ferramenta `resolve_relative_date`**. 
    Use a ferramenta resolve_relative_date assim:
    Action: resolve_relative_date  
    Action Input: {{"input": "ontem"}}
    - Nunca assuma a data diretamente ‚Äî utilize sempre a tool para garantir precis√£o.

    üß† **Regras de extra√ß√£o obrigat√≥rias**:

    - **Valor**: identificar n√∫meros como "500", "mil", "R$ 200"
    - **Tipo**:
    - receita ‚Üí "recebi", "ganhei", "vendi"
    - despesa ‚Üí "gastei", "paguei", "comprei"
    - **Categoria**: sugerir com base no contexto (ex: "mercado" ‚Üí "Alimenta√ß√£o")
    - **Conta**: sempre usar `conta_id=5` se n√£o especificado
    - **Data**: extrair express√£o e converter usando a tool `resolve_relative_date`
    - **Descri√ß√£o**: usar a frase original (ex: "ganhei 500 de sal√°rio")

    üì§ **SA√çDA FINAL DEVE SER NO FORMATO JSON CONFORME O EXEMPLO ABAIXO** a ser encaminhado para o agente gestor_dados:
    
    "dados": {{
        "valor": 500.0,
        "tipo": "receita",
        "categoria": "Sal√°rio",
        "conta_id": 5,
        "data_transacao": "2025-07-25",
        "descricao": "ganhei 500 de sal√°rio"
    }}

    üëë **REGRAS DE OURO**:
    - A data deve vir da tool ‚Äî nunca invente ou assuma diretamente.
    """,
        expected_output="""Objeto JSON {dados_json} estruturado com todos os campos extra√≠dos corretamente e com data_transacao 
        j√° resolvida pela tool resolve_relative_date""",
        tools=[resolve_relative_date],
        agent=coletor_controle_financeiro
    )

    task_gestor_dados = Task(
        description=f"""Executar a transa√ß√£o no banco Supabase com os dados fornecidos pelo agente coletor_controle_financeiro.
        Os dados s√£o: {dados_json}. Os dados devem estar alinhado com aqueles coletados pelo agente coletor_controle_financeiro.""",
        expected_output="Resultado da queryno banco Supabase",
        agent=gestor_dados
    )

    task_redator = Task(
        description="""
        Sua miss√£o √© FORMULAR a resposta final com base no resultado da transa√ß√£o ou da consulta no banco Supabase.

        üéØ FORMATO PADR√ÉO PARA CONTROLE FINANCEIRO (CONTROLE_FINANCEIRO):
        - Sempre que poss√≠vel, use esse modelo fixo:
        
        üí∏ Sua transa√ß√£o foi registrada com sucesso:
        ‚Ä¢ Valor: R$ {dados_json["valor"]}
        ‚Ä¢ Categoria: {dados_json["categoria"]}
        ‚Ä¢ Data: {dados_json["data_transacao"]}
        ‚Ä¢ Conta: {dados_json["conta_id"]}
        üìù Descri√ß√£o: {dados_json["descricao"]}

        ‚ö†Ô∏è NUNCA inclua "ID de conta", "ID de categoria", "json" ou qualquer detalhe t√©cnico.
        ‚ö†Ô∏è Sempre formate o valor como moeda brasileira ("R$ 150,00")
        ‚ö†Ô∏è Sempre use data no formato DD/MM/AAAA

        üéØ FORMATO PADR√ÉO PARA CONSULTA DE ATIVO (CONSULTA_ATIVO):
        - Exemplo: "A cota√ß√£o atual de PETR4 √© R$ 32,70."

        üëë REGRAS DE OURO:
        - NUNCA exiba c√≥digo, JSON bruto, IDs ou termos t√©cnicos
        - A resposta deve ser CLARA, HUMANA e NATURAL
        - Inicie com um √≠cone: üí∏ ou üìà dependendo do tipo
        """,
        expected_output="""Resposta final clara e amig√°vel para o usu√°rio e fiel ao resultado da 
        transa√ß√£o ou da consulta no banco Supabase feita pelo agente gestor_dados""",
        agent=redator
    )


    return Crew(
        agents=[coletor_controle_financeiro, gestor_dados, redator],
        tasks=[task_coleta_controle_financeiro, task_gestor_dados, task_redator],
        process=Process.sequential,
        memory=True,
        entity_memory=memory,
        verbose=True,
    )

# === PARTE 5: Crew: Consulta de Ativos Financeiros ===

def crew_consulta_ativos(tools, llm, memory, dados_json):
    coletor_ativos = Agent(
        role="Coletor de Dados de Ativos",
        goal="Extrair informa√ß√µes necess√°rias para consulta de ativos (ex: s√≠mbolo, tipo de dado).",
        backstory="Especialista em finan√ßas e an√°lise de mercado, focado em interpretar pedidos de ativos.",
        tools=tools,
        llm=llm,
        verbose=True,
        allow_delegation=False
    )

    analista_ativos = Agent(
        role="Consultor de Mercado Financeiro",
        goal="Consultar dados atualizados do ativo usando YFinance.",
        backstory="Profissional de mercado que busca pre√ßos, tend√™ncias e dados em tempo real.",
        tools=tools,
        llm=llm,
        verbose=True,
        allow_delegation=False
    )

    redator = Agent(
        role="Redator de Informa√ß√µes de Ativos",
        goal="Responder ao usu√°rio com clareza sobre o ativo solicitado.",
        backstory="Respons√°vel por transformar resultados t√©cnicos de mercado em mensagens claras.",
        tools=[],
        llm=llm,
        verbose=True,
        allow_delegation=False
    )

    task_coleta_ativos = Task(
        description=f"""
        Extrair informa√ß√µes necess√°rias para consulta de ativos.
        Verificar se tem:
            - simbolo: c√≥digo do ativo (PETR4, USDBRL, ^BVSP)
            - tipo_consulta: "cotacao", "analise", "historico"
        - Sempre usar a tool `resolve_relative_date` para calcular a data.
        - Use a ferramenta resolve_relative_date assim:
            Action: resolve_relative_date  
            Action Input: {{"input": "ontem"}}
        - Resultado:
        {{
        "dados": {{
                    "simbolo": "PETR4", 
                    "tipo_consulta": "cotacao" | "analise",
                    "data": "2025-07-25"
                }}
        }}
        """,
        expected_output="Json com informa√ß√µes necess√°rias para consulta de ativos",
        agent=coletor_ativos
    )

    task_analise_ativos = Task(
        description=f"""Obter informa√ß√µes sobre o ativo usando os dados: {dados_json}""",
        expected_output="Cota√ß√£o ou an√°lise do ativo",
        agent=analista_ativos
    )

    task_redator = Task(
        description="Formate e entregue o resultado ao usu√°rio de forma clara e natural.",
        expected_output="Resposta final amig√°vel sobre o ativo",
        agent=redator
    )

    return Crew(
        agents=[coletor_ativos, analista_ativos, redator],
        tasks=[task_coleta_ativos, task_analise_ativos, task_redator],
        process=Process.sequential,
        memory=True,
        entity_memory=memory,
        verbose=True
    )

# === PARTE 6: Execu√ß√£o principal ===

async def assist_financ_core(question: str, user_id: str) -> str:
    llm = ChatOpenAI(model="gpt-4o-mini")
    
    is_new = is_new_conversation(question)
    session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
    memory = get_session_memory(user_id, session_id)

    if is_new:
        try:
            memory.clear()
        except: pass

    # Inicializa adaptadores
    tools = []
    tools.append(resolve_relative_date)

    supabase = try_initialize_mcp_adapter(StdioServerParameters(
        command="npx",
        args=["-y", "@supabase/mcp-server-supabase@latest", "--project-ref=rhtnuzfmshfmreuffqox"],
        env={"SUPABASE_ACCESS_TOKEN": os.getenv("SUPABASE_ACCESS_TOKEN", ""), **os.environ}
    ), "Supabase")

    yfinance = try_initialize_mcp_adapter(StdioServerParameters(
        command="uvx",
        args=["yfmcp@latest"]
    ), "YFinance")

    for adapter in [supabase, yfinance]:
        if adapter:
            tools.extend(adapter.tools)
            tools.append(resolve_relative_date) # Adiciona a tool de resolu√ß√£o de data relativa

    classificador = criar_agente_classificador(tools, llm)

    classificacao_task = Task(
        description=f"""
        üì• Sua miss√£o √© analisar a seguinte frase: "{question}" e **obrigatoriamente** gerar um objeto JSON no seguinte formato:

        üìã FORMATO FIXO OBRIGAT√ìRIO:
        {{
        "classificacao": "CONTROLE_FINANCEIRO" | "CONSULTA_ATIVO",
        "status": "COMPLETO",
        "dados": {{
            // para CONTROLE_FINANCEIRO:
            "valor": 1500.00,
            "tipo": "receita" | "despesa",
            "conta_id": 5,
            "categoria": "Alimenta√ß√£o",
            "data_transacao": "2025-07-20 | hoje | ontem | anteontem | 15/07/2025",
            "descricao": "Descri√ß√£o livre da transa√ß√£o"

            // para CONSULTA_ATIVO:
            "simbolo": "PETR4",
            "tipo_consulta": "cotacao" | "analise"
        }}
        }}

        ‚ö†Ô∏è Regras obrigat√≥rias:
        - N√ÉO SAIA do formato acima.
        - N√ÉO inclua observa√ß√µes, explica√ß√µes ou textos soltos.
        - SEMPRE inclua status="COMPLETO"
        - Use sempre conta_id=5 se n√£o informado
        - Sempre que poss√≠vel, preencha a descri√ß√£o com base na frase original
        """,
        expected_output="Objeto JSON {dados_json} estruturado como especificado acima",
        agent=classificador
    )

    crew_classificacao = Crew(
        agents=[classificador],
        tasks=[classificacao_task],
        process=Process.sequential,
        memory=True,
        entity_memory=memory,
        verbose=True,
    )

    import json

    resultado = await crew_classificacao.kickoff_async()
    resposta_str = str(resultado)

    try:
        resposta_json = json.loads(resposta_str)
    except:
        return "Erro ao interpretar a resposta do classificador."

    logger.info(f"üîç Resposta JSON do classificador: {resposta_json}")

    classificacao = resposta_json.get("classificacao")
    dados = resposta_json.get("dados")


    # Decide qual crew executar
    if classificacao == "CONTROLE_FINANCEIRO":
        crew = crew_controle_financeiro(tools, llm, memory, dados)
    elif classificacao == "CONSULTA_ATIVO":
        crew = crew_consulta_ativos(tools, llm, memory, dados)
    else:
        return "Classifica√ß√£o desconhecida. N√£o sei o que fazer com isso."

    # Executa a pr√≥xima etapa
    resposta_final = await crew.kickoff_async()
    return str(resposta_final)


# === PARTE 7: Tool MCP + fun√ß√£o de teste e entrada CLI ===

@mcp.tool(name="assistente_financeiro_inteligente")
async def assistente_financeiro_tool(question: str, user_id: str) -> str:
    return await assist_financ_core(question, user_id)

async def test_assistente_financeiro(question: str, user_id: str):
    return await assist_financ_core(question, user_id)


if __name__ == "__main__":
    mcp.run(transport="sse", host="127.0.0.1", port=8005)
